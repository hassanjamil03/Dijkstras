class Node:
    def __init__(self, Distances):
        self.Distances = Distances
        self.IsActive = True
        self.DistanceTo = 0


nodes = []
Unodes = []


def Dijkstras(CNode):
    CNode = nodes[CNode]
    if len(CNode.distances) == 0 and len(nodes) > 0: Dijkstras(Unodes[-1])
    NNodeDis = min([point[0] for point in CNode.Distances])
    NNode = nodes[NNodeDis]


"""
example: 

nodes = [a, b, c, r, f, w, g, h]; all items in this list are node objects
nodes[x].distances = [(1, 7), (3, 5), (2, 3)]; 1, 2, and 3 represent distance from node at index x;  7, 5, and 3 represent nodes with that number
nodes[x].dist = distance of node x from the first node


def dijkstras(current node number):
    get current node object (cnode = node[current node number)
    get nearest node (nnode = node[min(cnode.distances)])
        if cnode.distances is empty and nodes list isnt empty: dijkstras(usednodes[-1])
    distance to nearest node is equal to = distance to last node ('a') + distance to nearest node (nnode.distanceto = cnode.distanceto + cnode.
    cnode.distances.pop(whichever element contains nnode) 
    transfer node to usednodes list (usednodes.append(cnode))
    dijkstras(nearest node number)
---------------------------------attempt 2------------------------

nodes = [a, b, c, r, f, w, g, h]; all items in this list are node objects

nodes[x].distances = [(1, 7), (3, 5), (2, 3)]; 1, 2, and 3 represent distance from node at index x;  7, 5, and 3 represent
    nodes with that number

//**nodes[x].dist = distance of node x from the first node. first/starting node will always have a dist of 0**// 
    obselete. use distances list instead

nodes[x].isactive = true or false value representing whether the node is still active (ie has not been marked a visited 
    node yet)

distances = [0, 5, 13, 25, 32]; all items in this list represent distance from starting node to whichever node the index 
    corresponds with, eg distances[1] means the distance from the starting node (node 0) to node 1 (which in this case 
    is 5). distances has length equal to number of nodes present and initially starts out with all elements excpet first
    equal to 'inf'  


def dijkstra(noden): (noden = node number, 0-indexed)
    get current node object 
    (
        cnode = node[noden]
    )

    (
        min_point = 'inf'
    )

    for every node connected to the current node
    (
        for point in cnode.distances:
    )
        update distance to node 
        (
            distance = distance[noden] + point[0]
            node = nodes[point[1]]
            node_distance = distance[point[1]]
            if node_distance == 'inf' or distance < node_distance: 
                node_distance = distance
        )

    mark cnode as inactive 
    (
        cnode.isactive = false
    )
    run djikstras again this time on the node nearest to the first node
    (
        newdist = [distances[node] for node in range(len(distances)) if nodes[node].isactive] 
        nnode = min(newdist)
        if nnode = len(distances)-1:
            print("done")
    )
"""
